# A0121319R
###### src\parser\ActionParser.java
``` java
 */

package parser;

public class ActionParser {

	protected enum ACTION_TYPE {
		ADD, SHOW, SEARCH, UPDATE, DONE, UNDONE, DELETE, UNDO, INVALID, EXIT, HELP, FP, CFP, CLEAR;
	}

	/*
	 * This method extracts the user's specified action and returns it as an
	 * ACTION_TYPE
	 * 
	 * Assumptions: 1) The user action is always in the first index in the
	 * entire String
	 */
	protected static ACTION_TYPE setUserAction(String str) {
		String[] strArray = str.split(ParserConstants.REGEX_WHITESPACES);
		String userAction = strArray[ParserConstants.INDEX_FIRST];

		if (compareAddKeywords(userAction)) {
			return ACTION_TYPE.ADD;
		} else if (compareShowKeywords(userAction)) {
			return ACTION_TYPE.SHOW;
		} else if (compareSearchKeywords(userAction)) {
			return ACTION_TYPE.SEARCH;
		} else if (compareUpdateKeywords(userAction)) {
			return ACTION_TYPE.UPDATE;
		} else if (compareDoneKeywords(userAction)) {
			return ACTION_TYPE.DONE;
		} else if (compareUndoneKeywords(userAction)) {
			return ACTION_TYPE.UNDONE;
		} else if (compareDeleteKeywords(userAction)) {
			return ACTION_TYPE.DELETE;
		} else if (compareUndoKeywords(userAction)) {
			return ACTION_TYPE.UNDO;
		} else if (compareExitKeywords(userAction)) {
			return ACTION_TYPE.EXIT;
		} else if (userAction.equalsIgnoreCase("help")) {
			return ACTION_TYPE.HELP;
		} else if (userAction.equalsIgnoreCase("fp")) {
			return ACTION_TYPE.FP;
		} else if (userAction.equalsIgnoreCase("cfp")) {
			return ACTION_TYPE.CFP;
		} else if (userAction.equalsIgnoreCase("clear")) {
			return ACTION_TYPE.CLEAR;
		} else {
			return ACTION_TYPE.INVALID;
		}
	}

	/*
	 * Comparison Methods
	 * 
	 * Compares the first word of the user's string input to the keywords
	 * specified under ParserConstants
	 */
	private static boolean compareAddKeywords(String str) {
		boolean containKeywords = false;
		for (String keyWords : ParserConstants.KW_COMMAND_ADD) {
			if (keyWords.equalsIgnoreCase(str)) {
				containKeywords = true;
			}
		}
		return containKeywords;
	}

	private static boolean compareShowKeywords(String str) {
		boolean containKeywords = false;
		for (String keyWords : ParserConstants.KW_COMMAND_SHOW) {
			if (keyWords.equalsIgnoreCase(str)) {
				containKeywords = true;
			}
		}
		return containKeywords;
	}

	private static boolean compareSearchKeywords(String str) {
		boolean containKeywords = false;
		for (String keyWords : ParserConstants.KW_COMMAND_SEARCH) {
			if (keyWords.equalsIgnoreCase(str)) {
				containKeywords = true;
			}
		}
		return containKeywords;
	}

	private static boolean compareUpdateKeywords(String str) {
		boolean containKeywords = false;
		for (String keyWords : ParserConstants.KW_COMMAND_UPDATE) {
			if (keyWords.equalsIgnoreCase(str)) {
				containKeywords = true;
			}
		}
		return containKeywords;
	}

	private static boolean compareDoneKeywords(String str) {
		boolean containKeywords = false;
		for (String keyWords : ParserConstants.KW_COMMAND_DONE) {
			if (keyWords.equalsIgnoreCase(str)) {
				containKeywords = true;
			}
		}
		return containKeywords;
	}

	private static boolean compareUndoneKeywords(String str) {
		boolean containKeywords = false;
		for (String keyWords : ParserConstants.KW_COMMAND_UNDONE) {
			if (keyWords.equalsIgnoreCase(str)) {
				containKeywords = true;
			}
		}
		return containKeywords;
	}

	private static boolean compareDeleteKeywords(String str) {
		boolean containKeywords = false;
		for (String keyWords : ParserConstants.KW_COMMAND_DELETE) {
			if (keyWords.equalsIgnoreCase(str)) {
				containKeywords = true;
			}
		}
		return containKeywords;
	}

	private static boolean compareUndoKeywords(String str) {
		boolean containKeywords = false;
		for (String keyWords : ParserConstants.KW_COMMAND_UNDO) {
			if (keyWords.equalsIgnoreCase(str)) {
				containKeywords = true;
			}
		}
		return containKeywords;
	}

	private static boolean compareExitKeywords(String str) {
		boolean containKeywords = false;
		for (String keyWords : ParserConstants.KW_COMMAND_EXIT) {
			if (keyWords.equalsIgnoreCase(str)) {
				containKeywords = true;
			}
		}
		return containKeywords;
	}
}
```
###### src\parser\ActionParserTest.java
``` java
 */

package parser;

import static org.junit.Assert.*;

import java.util.ArrayList;

import org.junit.Before;
import org.junit.Test;

import parser.ActionParser.ACTION_TYPE;

public class ActionParserTest {

	private static ArrayList<ACTION_TYPE> arr = new ArrayList<ACTION_TYPE>();

	@Before
	public void setUp() {
		arr.add(ACTION_TYPE.ADD);
		arr.add(ACTION_TYPE.ADD);
		arr.add(ACTION_TYPE.DELETE);
		arr.add(ACTION_TYPE.DELETE);
		arr.add(ACTION_TYPE.DELETE);
		arr.add(ACTION_TYPE.SHOW);
		arr.add(ACTION_TYPE.SHOW);
		arr.add(ACTION_TYPE.SEARCH);
		arr.add(ACTION_TYPE.SEARCH);
		arr.add(ACTION_TYPE.UPDATE);
		arr.add(ACTION_TYPE.UPDATE);
		arr.add(ACTION_TYPE.UPDATE);
		arr.add(ACTION_TYPE.DONE);
		arr.add(ACTION_TYPE.DONE);
		arr.add(ACTION_TYPE.UNDO);
		arr.add(ACTION_TYPE.EXIT);
		arr.add(ACTION_TYPE.EXIT);
		arr.add(ACTION_TYPE.INVALID);
	}

	@Test
	public void testActionParser() {
		String test[] = { "ADD", "new", "DELETE", "rm", "dEl", "Show", "disPLAY", "search", "fInd", "edit", "CHANGE",
				"update", "done", "MarK", "undo", "exit", "quit", "LOL" };
		for (int i = 0; i < test.length; i++) {
			ACTION_TYPE result = ActionParser.setUserAction(test[i]);
			ACTION_TYPE expected = arr.get(i);
			assertEquals(expected, result);
		}
	}

}
```
###### src\parser\DateTimeParser.java
``` java
 */

package parser;

import java.util.ArrayList;

import org.joda.time.LocalDate;
import org.joda.time.LocalDateTime;
import org.joda.time.LocalTime;
import org.joda.time.format.DateTimeFormat;

public class DateTimeParser {

	private static ArrayList<String> dateArgs;
	private static ArrayList<String> timeArgs;

	/*
	 * This method parses the input String for date/time arguments
	 */
	protected static void getDateTimeArgs(String str) throws InvalidInputException {
		LocalDate now = new LocalDate();
		dateArgs = new ArrayList<String>();
		timeArgs = new ArrayList<String>();

		LocalDate startDate = null;
		LocalDate endDate = null;
		LocalTime startTime = null;
		LocalTime endTime = null;

		ArrayList<String> arr = Parser.toArrayList(str, ParserConstants.CHAR_SINGLE_WHITESPACE);
		ArrayList<String> startArr = new ArrayList<String>();
		ArrayList<String> endArr = new ArrayList<String>();

		/** Partitioning **/
		partition(arr, startArr, endArr);

		/** Start Date/Time Arguments **/
		try {
			for (String string : startArr) {
				convertTodayToDateTime(string);
				convertTmrToDateTime(string);
				parseForDate(now, string);
				parseForTime(string);
			}
		} catch (IndexOutOfBoundsException e) {

		}

		if (dateArgs.size() > 1 || timeArgs.size() > 1) {
			throw new InvalidInputException("Invalid input: Too many inputs");
		} else if (dateArgs.isEmpty() && !timeArgs.isEmpty()) {
			dateArgs.add(getDate(0));
		} else if (!dateArgs.isEmpty() && timeArgs.isEmpty()) {
			timeArgs.add("");
		} else if (dateArgs.isEmpty() && timeArgs.isEmpty()) {
			dateArgs.add("");
			timeArgs.add("");
		}

		try {
			startDate = DateTimeFormat.forPattern(ParserConstants.FORMAT_DATE_STORAGE)
					.parseLocalDate(dateArgs.get(ParserConstants.INDEX_FIRST));
			startTime = DateTimeFormat.forPattern(ParserConstants.FORMAT_TIME_STORAGE)
					.parseLocalTime(timeArgs.get(ParserConstants.INDEX_FIRST));
		} catch (IllegalArgumentException e) {

		}

		/** End Date/Time Arguments **/
		try {
			for (String string : endArr) {
				convertTodayToDateTime(string);
				convertTmrToDateTime(string);
				parseForDate(now, string);
				parseForTime(string);
			}
		} catch (IndexOutOfBoundsException e) {

		}

		if (dateArgs.size() > 2 || timeArgs.size() > 2) {
			throw new InvalidInputException("Invalid input: Too many inputs");
		} else if (dateArgs.size() == 1 && timeArgs.size() == 2) {
			if (startDate != null) {
				dateArgs.add(startDate.toString(ParserConstants.FORMAT_DATE_STORAGE));
			} else {
				dateArgs.add(getDate(0));
			}
		} else if (dateArgs.size() == 2 && timeArgs.size() == 1) {
			timeArgs.add("");
		} else if (dateArgs.size() == 1 && timeArgs.size() == 1) {
			dateArgs.add("");
			timeArgs.add("");
		}
		
		// Shift the endDate/Time to the first index such that it can be shown on the UI
		if (dateArgs.get(0).isEmpty() && !dateArgs.get(1).isEmpty() && timeArgs.get(0).isEmpty()
				&& !timeArgs.get(1).isEmpty()) {
			dateArgs.set(0, dateArgs.get(1));
			dateArgs.set(1, "");
			timeArgs.set(0, timeArgs.get(1));
			timeArgs.set(1, "");
		}

		try {
			endDate = DateTimeFormat.forPattern(ParserConstants.FORMAT_DATE_STORAGE)
					.parseLocalDate(dateArgs.get(ParserConstants.INDEX_SECOND));
			endTime = DateTimeFormat.forPattern(ParserConstants.FORMAT_TIME_STORAGE)
					.parseLocalTime(timeArgs.get(ParserConstants.INDEX_SECOND));
		} catch (IllegalArgumentException e) {

		}

		if (startDate != null && endDate != null) {
			if (startDate.compareTo(endDate) == 1) {
				throw new InvalidInputException("Invalid input: Start date cannot come after the end date");
			} else if (startDate.compareTo(endDate) == 0) {
				if (startTime.compareTo(endTime) == 1) {
					throw new InvalidInputException("Invalid input: Start time cannot come after the end time");
				} else if (startTime.compareTo(endTime) == 0) {
					throw new InvalidInputException(
							"Invalid input: Start time cannot be the same as the end time within the same day");
				}
			}
		}
	}

	/*
	 * Adds today's date to the number of days specified and return the sum as a
	 * String in the format "dd/MM/yy"
	 */
	protected static String getDate(int plus) {
		LocalDateTime date = LocalDateTime.now();
		date = date.plusDays(plus);
		return date.toString(ParserConstants.FORMAT_DATE_STORAGE);
	}

	/***** GETTERS *****/
	protected static ArrayList<String> getDateArgs() {
		return dateArgs;
	}

	protected static ArrayList<String> getTimeArgs() {
		return timeArgs;
	}

	/*
	 * Parses the target String for acceptable date formats and adds it to
	 * dateArgs
	 * 
	 * Throws an InvalidInputException if the date entered has passed
	 */
	private static void parseForDate(LocalDate now, String target) throws InvalidInputException {
		LocalDate date = null;
		for (String keyword : ParserConstants.FORMAT_DATE_WITHOUT_YEAR) {
			try {
				date = DateTimeFormat.forPattern(keyword).parseLocalDate(target).withYear(now.getYear());
				dateArgs.add(date.toString(ParserConstants.FORMAT_DATE_STORAGE));
			} catch (IllegalArgumentException | NullPointerException e) {

			}
		}
		for (String keyword : ParserConstants.FORMAT_DATE_WITH_YEAR) {
			try {
				date = DateTimeFormat.forPattern(keyword).parseLocalDate(target);
				dateArgs.add(date.toString(ParserConstants.FORMAT_DATE_STORAGE));
			} catch (IllegalArgumentException | NullPointerException e) {

			}
		}
	}

	/*
	 * Parses the target String for acceptable time formats and adds it to
	 * timeArgs
	 */
	private static void parseForTime(String target) throws InvalidInputException {
		LocalTime time = null;
		for (String keyword : ParserConstants.FORMAT_TIME) {
			try {
				time = DateTimeFormat.forPattern(keyword).parseLocalTime(target);
				timeArgs.add(time.toString(ParserConstants.FORMAT_TIME_STORAGE));
			} catch (IllegalArgumentException | NullPointerException e) {

			}
		}
	}

	private static void convertTmrToDateTime(String target) {
		for (String keyword : ParserConstants.KW_TOMORROW) {
			if (target.equals(keyword)) {
				dateArgs.add(getDate(1));
			}
		}
	}

	private static void convertTodayToDateTime(String target) {
		for (String keyword : ParserConstants.KW_TODAY) {
			if (target.equals(keyword)) {
				dateArgs.add(getDate(0));
			}
		}
	}

	/*
	 * This method partitions arr into 2 parts: startArr and endArr.
	 * 
	 * Partitions are determined primarily by the presence of ">" and by
	 * elements contained in KW_END
	 */
	private static void partition(ArrayList<String> arr, ArrayList<String> startArr, ArrayList<String> endArr) {
		if (arr.contains(ParserConstants.CHAR_RIGHT_ANGLE_BRACKET)) {
			int strictIndex = Parser.indexOf(ParserConstants.CHAR_RIGHT_ANGLE_BRACKET, arr);
			ArrayList<String> temp = new ArrayList<String>();
			for (int i = strictIndex; i < arr.size(); i++) {
				temp.add(arr.get(i));
			}
			int endIndex = Parser.indexOf(ParserConstants.KW_END, temp);
			if (endIndex == -1) {
				for (int i = 0; i < temp.size(); i++) {
					startArr.add(temp.get(i));
				}
			} else {
				for (int i = 0; i < endIndex; i++) {
					startArr.add(temp.get(i));
				}
				for (int i = endIndex; i < temp.size(); i++) {
					endArr.add(temp.get(i));
				}
			}
		} else {
			int endIndex = Parser.indexOf(ParserConstants.KW_END, arr);
			if (endIndex == -1) {
				for (int i = 0; i < arr.size(); i++) {
					startArr.add(arr.get(i));
				}
			} else {
				for (int i = 0; i < endIndex; i++) {
					startArr.add(arr.get(i));
				}
				for (int i = endIndex; i < arr.size(); i++) {
					endArr.add(arr.get(i));
				}
			}
		}
	}
}
```
###### src\parser\DateTimeParserTest.java
``` java
 */

package parser;

import static org.junit.Assert.*;

import java.util.ArrayList;

import org.junit.Test;

public class DateTimeParserTest {

	private ArrayList<String> resultTime = new ArrayList<String>();
	private ArrayList<String> resultDate = new ArrayList<String>();
	private ArrayList<String> expectedTime = new ArrayList<String>();
	private ArrayList<String> expectedDate = new ArrayList<String>();

	@Test
	public void testForTwoDateAndTimeArgs() throws InvalidInputException {
		String test = "add camping trip at somewhere from 12-12-15 11:00 to 13/12/15 1200";
		DateTimeParser.getDateTimeArgs(test);
		resultTime = DateTimeParser.getTimeArgs();
		resultDate = DateTimeParser.getDateArgs();
		expectedTime.add("1100");
		expectedTime.add("1200");
		expectedDate.add("12/12/15");
		expectedDate.add("13/12/15");
		assertEquals(expectedTime, resultTime);
		assertEquals(expectedDate, resultDate);
	}

	@Test
	public void testOneStartDateAndTime() throws InvalidInputException {
		String test = "add meeting with boss today 10.30am";
		DateTimeParser.getDateTimeArgs(test);
		resultDate = DateTimeParser.getDateArgs();
		resultTime = DateTimeParser.getTimeArgs();
		expectedDate = add(DateTimeParser.getDate(0), "");
		expectedTime = add("1030", "");
		assertEquals(expectedDate, resultDate);
		assertEquals(expectedTime, resultTime);
	}

	@Test
	public void testOneEndDateAndTime() throws InvalidInputException {
		String test = "add submit maths assignment by tomorrow 2359";
		DateTimeParser.getDateTimeArgs(test);
		resultDate = DateTimeParser.getDateArgs();
		resultTime = DateTimeParser.getTimeArgs();
		expectedDate = add(DateTimeParser.getDate(1), "");
		expectedTime = add("2359", "");
		assertEquals(expectedDate, resultDate);
		assertEquals(expectedTime, resultTime);
	}

	@Test
	public void testTravellingCasual() throws InvalidInputException {
		String test = "add drive from clementi to yishun today 10:00pm";
		DateTimeParser.getDateTimeArgs(test);
		resultDate = DateTimeParser.getDateArgs();
		resultTime = DateTimeParser.getTimeArgs();
		expectedDate = add(DateTimeParser.getDate(0), "");
		expectedTime = add("2200", "");
		assertEquals(expectedDate, resultDate);
		assertEquals(expectedTime, resultTime);
	}

	@Test
	public void testTravellingStrictStartInputs() throws InvalidInputException {
		String test = "add drive from clementi to yishun > today 10:00pm";
		DateTimeParser.getDateTimeArgs(test);
		resultDate = DateTimeParser.getDateArgs();
		resultTime = DateTimeParser.getTimeArgs();
		expectedDate = add(DateTimeParser.getDate(0), "");
		expectedTime = add("2200", "");
		assertEquals(expectedDate, resultDate);
		assertEquals(expectedTime, resultTime);
	}

	@Test
	public void testTravellingStrictBothInputs() throws InvalidInputException {
		String test = "add drive from clementi to yishun > today 10:00pm to tomorrow 12.37pm";
		DateTimeParser.getDateTimeArgs(test);
		resultDate = DateTimeParser.getDateArgs();
		resultTime = DateTimeParser.getTimeArgs();
		expectedDate = add(DateTimeParser.getDate(0), DateTimeParser.getDate(1));
		expectedTime = add("2200", "1237");
		assertEquals(expectedDate, resultDate);
		assertEquals(expectedTime, resultTime);
	}

	@Test(expected = InvalidInputException.class)
	public void testWatchMovieCasual() throws InvalidInputException {
		String test = "add watch day after tomorrow today 10am";
		DateTimeParser.getDateTimeArgs(test);
		resultDate = DateTimeParser.getDateArgs();
		resultTime = DateTimeParser.getTimeArgs();
		expectedDate = add(DateTimeParser.getDate(1), DateTimeParser.getDate(0));
		expectedTime = add("1000", "");
		assertEquals(expectedDate, resultDate);
		assertEquals(expectedTime, resultTime);
	}

	@Test
	public void testWatchMovieStrict() throws InvalidInputException {
		String test = "add watch day after tomorrow > today 10am";
		DateTimeParser.getDateTimeArgs(test);
		resultDate = DateTimeParser.getDateArgs();
		resultTime = DateTimeParser.getTimeArgs();
		expectedDate = add(DateTimeParser.getDate(0), "");
		expectedTime = add("1000", "");
		assertEquals(expectedDate, resultDate);
		assertEquals(expectedTime, resultTime);
	}

	@Test
	public void testForOneEndDateAndTwoTimeArgs() throws InvalidInputException {
		String test = "add event from 10:00 to 12.dec 10:00";
		DateTimeParser.getDateTimeArgs(test);
		resultDate = DateTimeParser.getDateArgs();
		resultTime = DateTimeParser.getTimeArgs();
		expectedTime = add("1000", "1000");
		expectedDate = add(DateTimeParser.getDate(0), "12/12/15");
		assertEquals(expectedTime, resultTime);
		assertEquals(expectedDate, resultDate);
	}

	@Test(expected = InvalidInputException.class)
	public void testForTooManyStartInputs() throws InvalidInputException {
		String test = "add event from 10/10/15 11:00 11:01 to 11/10/15 12:34";
		DateTimeParser.getDateTimeArgs(test);
	}

	@Test(expected = InvalidInputException.class)
	public void testForTooManyEndInputs() throws InvalidInputException {
		String test = "add event from 11:00 to 12:34 12:43";
		DateTimeParser.getDateTimeArgs(test);
	}

	@Test(expected = InvalidInputException.class)
	public void testTooManyEndDateInput() throws InvalidInputException {
		String test = "add event from 12/12/20 to 13/12/20 14/12/20";
		DateTimeParser.getDateTimeArgs(test);
	}

	@Test(expected = InvalidInputException.class)
	public void testEndDateBeforeStartDate() throws InvalidInputException {
		String test = "add training tomorrow to today";
		DateTimeParser.getDateTimeArgs(test);
	}

	@Test(expected = InvalidInputException.class)
	public void testEndTimeBeforeStartTime() throws InvalidInputException {
		String test = "add training 11am to 10am";
		DateTimeParser.getDateTimeArgs(test);
	}

	// For easier adding to ArrayLists
	private static ArrayList<String> add(String start, String end) {
		ArrayList<String> returnArr = new ArrayList<String>();
		returnArr.add(start);
		returnArr.add(end);
		return returnArr;
	}
}
```
###### src\parser\EventTaskParser.java
``` java
 */

package parser;

import java.util.ArrayList;

import org.joda.time.format.DateTimeFormat;

public class EventTaskParser {

	/*
	 * This method returns a String representing the event/task argument. An
	 * InvalidInputException is thrown when the resulting String extracted is
	 * empty.
	 */
	protected static String getEventTask(String str) throws InvalidInputException {
		ArrayList<String> arr = Parser.toArrayList(str.trim(), ParserConstants.CHAR_SINGLE_WHITESPACE);
		assert (arr.size() >= 2);
		// Checks for the presence of any integer which represents an index
		// argument. Removes it from the
		// second index if it exists
		try {
			if (arr.get(ParserConstants.INDEX_SECOND).matches("^[+-]?\\d+")) {
				arr.remove(ParserConstants.INDEX_SECOND);
			}
		} catch (IndexOutOfBoundsException e) {

		}
		// Removes the action argument
		arr.remove(ParserConstants.INDEX_FIRST);

		int strictIndex = Parser.indexOf(ParserConstants.CHAR_RIGHT_ANGLE_BRACKET, arr);
		if (strictIndex == -1) {
			/*
			 * Order of removal 1) Remove any date/time arguments 2) Remove all
			 * elements after the last instance of a 'end' keyword 3) Remove all
			 * elements after the last instance of a 'start' keyword 4) Remove
			 * all elements after the last instance of any 'time' keyword
			 */
			ArrayList<String> temp = new ArrayList<String>();
			for (String transfer : arr) {
				temp.add(transfer);
			}
			for (String targetString : temp) {
				removeElements(targetString, arr, ParserConstants.FORMAT_DATE_WITH_YEAR);
				removeElements(targetString, arr, ParserConstants.FORMAT_DATE_WITHOUT_YEAR);
				removeElements(targetString, arr, ParserConstants.FORMAT_TIME);
			}
			int endIndex = Parser.lastIndexOf(ParserConstants.KW_END, arr);
			removeElementsStartingFromIndex(endIndex, arr);
			int startIndex = Parser.lastIndexOf(ParserConstants.KW_START, arr);
			removeElementsStartingFromIndex(startIndex, arr);
			int timeIndex = Parser.lastIndexOf(ParserConstants.KW_TIME, arr);
			removeElementsStartingFromIndex(timeIndex, arr);
			return returnString(arr);
		} else {
			for (int i = strictIndex; i < arr.size();) {
				arr.remove(i);
			}
			return returnString(arr);
		}
	}

	/*
	 * Converts the resulting ArrayList into a String and checks for the
	 * validity of the event/task argument.
	 * 
	 * Returns the String if it's valid. Throws an InvalidInputException if it's
	 * not.
	 */
	private static String returnString(ArrayList<String> arr) throws InvalidInputException {
		String toReturn = Parser.toString(arr).trim();
		if (toReturn.equals(ParserConstants.CHAR_SINGLE_BLANK)) {
			throw new InvalidInputException("Invalid input: Please enter an event/task name");
		} else {
			return toReturn;
		}
	}

	private static void removeElements(String targetString, ArrayList<String> arr, String[] format) {
		for (String formatString : format) {
			try {
				DateTimeFormat.forPattern(formatString).parseLocalDateTime(targetString);
				arr.remove(arr.indexOf(targetString));
			} catch (IllegalArgumentException | NullPointerException | IndexOutOfBoundsException e) {

			}
		}
	}

	private static void removeElementsStartingFromIndex(int index, ArrayList<String> arr) {
		if (index != -1) {
			for (int i = index; i < arr.size();) {
				arr.remove(i);
			}
		}
	}
}
```
###### src\parser\EventTaskParserTest.java
``` java
 */

package parser;

import static org.junit.Assert.*;

import org.junit.Test;

public class EventTaskParserTest {

	@Test
	public void testDateToday() throws InvalidInputException {
		String test = "add CS2103 tutorial today";
		String result = EventTaskParser.getEventTask(test);
		String expected = "CS2103 tutorial";
		assertEquals(expected, result);
	}

	@Test
	public void testDateTomorrowWithIndex() throws InvalidInputException {
		String test = "add 1000 CS2101 tutorial tomorrow";
		String result = EventTaskParser.getEventTask(test);
		String expected = "CS2101 tutorial";
		assertEquals(expected, result);
	}

	@Test
	public void testTwoDatesWithInvalidIndexAndTodayTmr() throws InvalidInputException {
		String test = "add -100 CS2100 tutorial from today to tomorrow";
		String result = EventTaskParser.getEventTask(test);
		String expected = "CS2100 tutorial";
		assertEquals(expected, result);
	}

	@Test
	public void testWatchMovieWithToday() throws InvalidInputException {
		String test = "add watch day after tomorrow today 9pm";
		String result = EventTaskParser.getEventTask(test);
		String expected = "watch day after tomorrow";
		assertEquals(expected, result);
	}

	@Test
	public void testWatchMovieWithProperDates() throws InvalidInputException {
		String test = "add watch day after tomorrow 12/12/15 9pm";
		String result = EventTaskParser.getEventTask(test);
		String expected = "watch day after";
		assertEquals(expected, result);
	}

	@Test
	public void testTravelFromPointToPoint() throws InvalidInputException {
		String test = "add drive from clementi to yishun from 12/12/15 9pm to 10pm";
		String result = EventTaskParser.getEventTask(test);
		String expected = "drive from clementi to yishun";
		assertEquals(expected, result);
	}

	@Test
	public void testWithAngleBrackets() throws InvalidInputException {
		String test = "add this event > 10 may";
		String result = EventTaskParser.getEventTask(test);
		String expected = "this event";
		assertEquals(expected, result);
	}

	@Test
	public void testWithIndex() throws InvalidInputException {
		String test = "update 1 meeting today 10am to 11am";
		String result = EventTaskParser.getEventTask(test);
		String expected = "meeting";
		assertEquals(expected, result);
	}

	@Test
	public void testWithoutDateTimeArgs() throws InvalidInputException {
		String test = "add event";
		String result = EventTaskParser.getEventTask(test);
		String expected = "event";
		assertEquals(expected, result);
	}

	@Test(expected = InvalidInputException.class)
	public void testInvalidInput() throws InvalidInputException {
		String test = "add";
		EventTaskParser.getEventTask(test);
	}

	@Test
	public void testProperInputWithKeywords() throws InvalidInputException {
		String test = "add meeting @ NUS tomorrow";
		String result = EventTaskParser.getEventTask(test);
		String expected = "meeting @ NUS";
		assertEquals(expected, result);
	}

	@Test
	public void testProperInputWithoutKeywords() throws InvalidInputException {
		String test = "add meeting 10/10/15 10am";
		String result = EventTaskParser.getEventTask(test);
		String expected = "meeting";
		assertEquals(expected, result);
	}

}
```
###### src\parser\FileParser.java
``` java
 */

package parser;

import java.util.ArrayList;

public class FileParser {

	/*
	 * This method parses for the file path specified by the user
	 * 
	 * Assumptions: 1)There are no spaces in the specified file path
	 */
	protected static String getFilePath(String str) throws InvalidInputException {
		ArrayList<String> arr = Parser.toArrayList(str.trim(), ParserConstants.CHAR_SINGLE_WHITESPACE);
		if (arr.size() > 2) {
			throw new InvalidInputException("Invalid input: Please enter a valid file path");
		} else {
			arr.remove(ParserConstants.INDEX_FIRST);
			String toReturn = Parser.toString(arr).trim();
			if (toReturn.equals(ParserConstants.CHAR_SINGLE_BLANK)) {
				throw new InvalidInputException("Invalid input: Please enter a valid file path");
			} else {
				return toReturn;
			}
		}
	}
}
```
###### src\parser\IndexParser.java
``` java
 */

package parser;

import java.util.ArrayList;

public class IndexParser {

	/*
	 * This method returns the index present in the String. It throws an
	 * InvalidInputException if no such index is found
	 */
	protected static int getIndex(String str) throws InvalidInputException {
		ArrayList<String> arr = Parser.toArrayList(str.trim(), ParserConstants.CHAR_SINGLE_WHITESPACE);
		if (indexPresent(arr)) {
			return Integer.parseInt(arr.get(ParserConstants.INDEX_SECOND));
		} else {
			throw new InvalidInputException("Invalid input: Please enter a valid index");
		}
	}

	/*
	 * Checks if there's an index argument in the String. Returns true if an
	 * integer is present in the second index, false if otherwise
	 * 
	 * ASSUMPTIONS: 1) In the input, the index always belongs to the second
	 * index
	 */
	private static boolean indexPresent(ArrayList<String> arr) throws InvalidInputException {
		try {
			return arr.get(ParserConstants.INDEX_SECOND).matches("^[0-9]*$");
		} catch (IndexOutOfBoundsException e) {
			throw new InvalidInputException("Invalid input: Please enter a valid index");
		}
	}
}
```
###### src\parser\IndexParserTest.java
``` java
 */

package parser;

import static org.junit.Assert.*;

import org.junit.Test;

public class IndexParserTest {

	@Test
	public void testGetIndexForDeleteAction() throws InvalidInputException {
		String test = "delete 1";
		int result = IndexParser.getIndex(test);
		int expected = 1;
		assertEquals(expected, result);
	}

	@Test(expected = InvalidInputException.class)
	public void testFailedGetIndexForDeleteAction() throws InvalidInputException {
		String test = "delete ";
		IndexParser.getIndex(test);
	}

	@Test
	public void testGetIndexForUpdateAction() throws InvalidInputException {
		String test = "update 2 event > 10am";
		int result = IndexParser.getIndex(test);
		int expected = 2;
		assertEquals(expected, result);
	}

	@Test(expected = InvalidInputException.class)
	public void testFailedGetIndexForUpdateAction() throws InvalidInputException {
		String test = "update event > 10am";
		IndexParser.getIndex(test);
	}

	@Test
	public void testGetIndexForDoneAction() throws InvalidInputException {
		String test = "mark 100";
		int result = IndexParser.getIndex(test);
		int expected = 100;
		assertEquals(expected, result);
	}

	@Test(expected = InvalidInputException.class)
	public void testGetIndexForUndoneAction() throws InvalidInputException {
		String test = "unmark -1";
		int result = IndexParser.getIndex(test);
		int expected = -1;
		assertEquals(expected, result);
	}
}
```
###### src\parser\InvalidInputException.java
``` java
 * 
 * This exception is thrown whenever an invalid input is detected in the user's string input
 */

package parser;

public class InvalidInputException extends Exception {

	private static final long serialVersionUID = 1L;
	private String message = "Invalid inputs";

	public InvalidInputException() {

	}

	public InvalidInputException(String str) {
		this.message = str;
	}

	public String getMessage() {
		return message;
	}
}
```
###### src\parser\Parser.java
``` java
 */

package parser;

import java.util.ArrayList;

import org.joda.time.format.DateTimeFormat;

import logic.AddTask;
import logic.ClearList;
import logic.Command;
import logic.DeleteTask;
import logic.ExitTask;
import logic.HelpTask;
import logic.InvalidTask;
import logic.MarkDoneTask;
import logic.MarkUndoneTask;
import logic.SearchTask;
import logic.SetFilePath;
import logic.ShowFilePath;
import logic.ShowTask;
import logic.UndoTask;
import logic.UpdateTask;
import parser.ActionParser.ACTION_TYPE;

public class Parser {

	/*
	 * Returns the corresponding classes with any arguments present in the
	 * user's input.
	 */
	public static Command setCommand(String str) {
		ACTION_TYPE action = ActionParser.setUserAction(str);

		switch (action) {
		case ADD:
			AddTask add = new AddTask();
			try {
				add.setEventTask(EventTaskParser.getEventTask(str));
				DateTimeParser.getDateTimeArgs(str);
				add.setDate(DateTimeParser.getDateArgs());
				add.setTime(DateTimeParser.getTimeArgs());
			} catch (InvalidInputException e) {
				InvalidTask invalid = new InvalidTask();
				return invalid;
			}
			return add;
		case SHOW:
			ShowTask show = new ShowTask();
			try {
				for (String key : ParserConstants.KW_COMMAND_DONE) {
					if (str.contains(key)) {
						show.setShowDone();
					}
				}
				if (str.contains(ParserConstants.KW_FLOAT)) {
					show.setShowFloat();
				}
				DateTimeParser.getDateTimeArgs(str);
				ArrayList<String> tempDateArr = DateTimeParser.getDateArgs();
				if (tempDateArr.get(ParserConstants.INDEX_SECOND).isEmpty()) {
					show.setDate(tempDateArr.get(ParserConstants.INDEX_FIRST));
				} else {
					throw new InvalidInputException();
				}
			} catch (InvalidInputException e) {
				InvalidTask invalid = new InvalidTask();
				return invalid;
			}
			return show;
		case SEARCH:
			SearchTask search = new SearchTask();
			try {
				search.setEventTask(EventTaskParser.getEventTask(str));
			} catch (InvalidInputException e) {
				InvalidTask invalid = new InvalidTask();
				return invalid;
			}
			return search;
		case UPDATE:
			UpdateTask update = new UpdateTask();
			try {
				update.setIndex(IndexParser.getIndex(str));
				update.setEventTask(EventTaskParser.getEventTask(str));
				DateTimeParser.getDateTimeArgs(str);
				update.setDate(DateTimeParser.getDateArgs());
				update.setTime(DateTimeParser.getTimeArgs());
			} catch (InvalidInputException e) {
				InvalidTask invalid = new InvalidTask();
				return invalid;
			}
			return update;
		case DONE:
			MarkDoneTask done = new MarkDoneTask();
			try {
				done.setIndex(IndexParser.getIndex(str));
			} catch (InvalidInputException e) {
				InvalidTask invalid = new InvalidTask();
				return invalid;
			}
			return done;
		case UNDONE:
			MarkUndoneTask undone = new MarkUndoneTask();
			try {
				undone.setIndex(IndexParser.getIndex(str));
			} catch (InvalidInputException e) {
				InvalidTask invalid = new InvalidTask();
				return invalid;
			}
			return undone;
		case DELETE:
			DeleteTask delete = new DeleteTask();
			try {
				delete.setIndex(IndexParser.getIndex(str));
			} catch (InvalidInputException e) {
				InvalidTask invalid = new InvalidTask();
				return invalid;
			}
			return delete;
		case UNDO:
			UndoTask undo = new UndoTask();
			return undo;
		case EXIT:
			ExitTask exit = new ExitTask();
			return exit;
		case HELP:
			HelpTask help = new HelpTask();
			return help;
		case FP:
			ShowFilePath filePath = new ShowFilePath();
			return filePath;
		case CFP:
			SetFilePath newFilePath = new SetFilePath();
			try {
				newFilePath.setFilePath(FileParser.getFilePath(str));
			} catch (InvalidInputException e) {
				InvalidTask invalid = new InvalidTask();
				return invalid;
			}
			return newFilePath;
		case CLEAR:
			ClearList clear = new ClearList();
			return clear;
		default:
			// Returned only if the action argument is invalid
			InvalidTask invalid = new InvalidTask();
			return invalid;
		}

	}

	/*
	 * Takes a String input and return it as an ArrayList with the specified
	 * String as the delimiter
	 */
	protected static ArrayList<String> toArrayList(String str, String delim) {
		String[] strArr = str.split(delim);
		ArrayList<String> strArrList = new ArrayList<String>();
		for (String strTransfer : strArr) {
			strArrList.add(strTransfer);
		}
		return strArrList;
	}

	/*
	 * Takes an ArrayList and appends its elements into a String and returns it
	 */
	protected static String toString(ArrayList<String> arr) {
		String toReturn = "";
		for (int i = 0; i < arr.size(); i++) {
			toReturn = toReturn + ParserConstants.CHAR_SINGLE_WHITESPACE + arr.get(i);
		}
		return toReturn;
	}

	/*
	 * Returns the index of the first occurrence of the given elements in arr
	 * contained in the String. Returns -1 if the String does not contain any of
	 * the elements in arr.
	 */
	protected static int indexOf(String[] arr, ArrayList<String> str) {
		ArrayList<String> temp = cloneToLowerCase(str);
		int index = str.size();
		for (String s : arr) {
			if (temp.indexOf(s) < index && temp.indexOf(s) != -1) {
				index = temp.indexOf(s);
			}
		}
		if (index == temp.size()) {
			return -1;
		} else {
			return index;
		}
	}

	/*
	 * Returns the index of the first occurrence of the key in the String, or -1
	 * if it does not contain the element.
	 */
	protected static int indexOf(String key, ArrayList<String> str) {
		ArrayList<String> temp = cloneToLowerCase(str);
		return temp.indexOf(key);
	}

	/*
	 * Returns the index of the last occurrence of the specified element in the
	 * String, or -1 if it does not contain the element.
	 */
	protected static int lastIndexOf(String[] arr, ArrayList<String> str) {
		ArrayList<String> temp = cloneToLowerCase(str);
		int index = -1;
		for (String s : arr) {
			if (temp.lastIndexOf(s) > index && temp.lastIndexOf(s) != -1) {
				index = temp.lastIndexOf(s);
			}
		}
		if (index == -1) {
			return -1;
		} else {
			return index;
		}
	}

	/*
	 * Checks for the relevant arguments in a specified partition. Returns true
	 * if it exists. False if otherwise
	 */
	protected static boolean isPresent(ArrayList<String> partition, String[] format) {
		for (String s1 : partition) {
			for (String s2 : format) {
				try {
					DateTimeFormat.forPattern(s2).parseLocalDateTime(s1);
					return true;
				} catch (NullPointerException | IllegalArgumentException e) {

				}
			}
		}
		return false;
	}

	private static ArrayList<String> cloneToLowerCase(ArrayList<String> str) {
		ArrayList<String> temp = new ArrayList<String>();
		for (int i = 0; i < str.size(); i++) {
			temp.add(str.get(i).toLowerCase());
		}
		return temp;
	}
}
```
###### src\parser\ParserConstants.java
``` java
 * 
 * Reused some constants from T11-3J
 */

package parser;

public class ParserConstants {

	protected static final String[] KW_TOMORROW = { "tomorrow", "tmr" };
	protected static final String[] KW_TODAY = { "today", "tdy" };

	// DateTimeFormat formats
	protected static final String[] FORMAT_DATE_WITH_YEAR = { "dd/MM/yy", "dd-MM-yy", "dd.MM.yy", "ddMMyy",
			"dd.MMMM.yy" };
	protected static final String[] FORMAT_DATE_WITHOUT_YEAR = { "dd/MM", "dd-MM", "dd.MM", "ddMM", "dd.MMMM" };
	protected static final String[] FORMAT_TIME = { "HHmm", "HH:mm", "HH.mm", "hha", "hh:mma", "hh.mma", "hhmma" };
	protected static final String FORMAT_DATE_STORAGE = "dd/MM/yy";
	protected static final String FORMAT_TIME_STORAGE = "HHmm";

	// Command Keywords (KW)
	protected static final String[] KW_COMMAND_ADD = { "add", "new" };
	protected static final String[] KW_COMMAND_DELETE = { "delete", "rm", "del" };
	protected static final String[] KW_COMMAND_SHOW = { "show", "display" };
	protected static final String[] KW_COMMAND_SEARCH = { "search", "find" };
	protected static final String[] KW_COMMAND_UPDATE = { "edit", "change", "update" };
	protected static final String[] KW_COMMAND_DONE = { "done", "mark" };
	protected static final String[] KW_COMMAND_UNDONE = { "undone", "unmark" };
	protected static final String[] KW_COMMAND_UNDO = { "undo" };
	protected static final String[] KW_COMMAND_EXIT = { "exit", "quit" };

	// User string input Keywords (KW)
	protected static final String[] KW_START = { "from", "on", "at" };
	protected static final String[] KW_END = { "by", "until", "till", "to", "-" };
	protected static final String[] KW_TIME = { "today", "tdy", "tomorrow", "tmr" };
	protected static final String KW_FLOAT = "float";

	// Indexes
	protected static final int INDEX_FIRST = 0;
	protected static final int INDEX_SECOND = 1;

	// REGEX
	protected static final String REGEX_WHITESPACES = "[\\s,]+";

	// Single Characters
	protected static final String CHAR_SINGLE_WHITESPACE = " ";
	protected static final String CHAR_SINGLE_BLANK = "";
	protected static final String CHAR_RIGHT_ANGLE_BRACKET = ">";
	protected static final String CHAR_PERIOD = ".";
	protected static final String CHAR_FORWARD_SLASH = "/";
	protected static final String CHAR_HYPHEN = "-";
}
```
###### src\tests\ParserTest.java
``` java
 */

package tests;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;

import java.util.ArrayList;

import org.joda.time.LocalDateTime;
import org.junit.Test;

import logic.AddTask;
import logic.ClearList;
import logic.DeleteTask;
import logic.InvalidTask;
import logic.MarkDoneTask;
import logic.MarkUndoneTask;
import logic.SearchTask;
import logic.ShowTask;
import logic.UpdateTask;
import parser.Parser;

public class ParserTest {

	ArrayList<String> expectedDate = new ArrayList<String>();
	ArrayList<String> expectedTime = new ArrayList<String>();

	@Test
	public void testSetCommandWithTimeOnly() {
		String test = "add CS2103T lecture from 2pm to 4:00pm";
		assertTrue(Parser.setCommand(test) instanceof AddTask);
		AddTask add = (AddTask) Parser.setCommand(test);

		String expected = "CS2103T lecture";
		expectedDate = add(getDate(0), getDate(0));
		expectedTime = add("1400", "1600");

		assertEquals(expected, add.getEventTask());
		assertEquals(expectedDate, add.getDate());
		assertEquals(expectedTime, add.getTime());
	}

	@Test
	public void testSetCommandWithValidDateOnly() {
		String test = "new reservist 9/5/16 to 30/5/16";
		assertTrue(Parser.setCommand(test) instanceof AddTask);
		AddTask add = (AddTask) Parser.setCommand(test);

		String expected = "reservist";
		expectedDate = add("09/05/16", "30/05/16");
		expectedTime = add("", "");

		assertEquals(expected, add.getEventTask());
		assertEquals(expectedDate, add.getDate());
		assertEquals(expectedTime, add.getTime());
	}

	@Test
	public void testSetCommandWithInvalidTimeInputs() {
		String test = "new event from 11:00 12:00 to 12:00";
		assertTrue(Parser.setCommand(test) instanceof InvalidTask);
	}

	@Test
	public void testForSearchAction() {
		String test = "seArch this event";
		assertTrue(Parser.setCommand(test) instanceof SearchTask);
		SearchTask search = (SearchTask) Parser.setCommand(test);

		String expected = "this event";
		assertEquals(expected, search.getEventTask());
	}

	@Test
	public void testForFailedSearchActionNoEventTaskArg() {
		String test = "search ";
		assertTrue(Parser.setCommand(test) instanceof InvalidTask);
	}

	@Test
	public void testUpdateAction() {
		String test = "update 1 new event name from 12/12/16 1100 to 13/12/16 12.00";
		assertTrue(Parser.setCommand(test) instanceof UpdateTask);
		UpdateTask update = (UpdateTask) Parser.setCommand(test);

		String expectedEvent = "new event name";
		int expectedIndex = 1;
		assertEquals(expectedEvent, update.getEventTask());
		expectedDate = add("12/12/16", "13/12/16");
		expectedTime = add("1100", "1200");
		assertEquals(expectedDate, update.getDate());
		assertEquals(expectedTime, update.getTime());
		assertEquals(expectedIndex, update.getIndex());
	}

	@Test
	public void testDoneAction() {
		String test = "done 2";
		assertTrue(Parser.setCommand(test) instanceof MarkDoneTask);
		MarkDoneTask done = (MarkDoneTask) Parser.setCommand(test);

		int expected = 2;
		assertEquals(expected, done.getIndex());
	}

	@Test
	public void testFailedDoneAction() {
		String test = "done";
		assertTrue(Parser.setCommand(test) instanceof InvalidTask);
	}

	@Test
	public void testUndoneAction() {
		String test = "undone 2";
		assertTrue(Parser.setCommand(test) instanceof MarkUndoneTask);
		MarkUndoneTask undone = (MarkUndoneTask) Parser.setCommand(test);

		int expected = 2;
		assertEquals(expected, undone.getIndex());
	}

	@Test
	public void testFailedUndoneAction() {
		String test = "unmark";
		assertTrue(Parser.setCommand(test) instanceof InvalidTask);
	}

	@Test
	public void testDeleteAction() {
		String test = "deL 2";
		assertTrue(Parser.setCommand(test) instanceof DeleteTask);
		DeleteTask delete = (DeleteTask) Parser.setCommand(test);

		int expected = 2;
		assertEquals(expected, delete.getIndex());
	}

	@Test
	public void testFailedDeleteAction() {
		String test = "delete ";
		assertTrue(Parser.setCommand(test) instanceof InvalidTask);
	}

	@Test
	public void testShowAction() {
		String test = "display today";
		assertTrue(Parser.setCommand(test) instanceof ShowTask);
		ShowTask show = (ShowTask) Parser.setCommand(test);

		String expected = getDate(0);
		assertEquals(expected, show.getDate());
	}

	@Test
	public void testShowDoneForTodayAction() {
		String test = "display done today";
		assertTrue(Parser.setCommand(test) instanceof ShowTask);
		ShowTask show = (ShowTask) Parser.setCommand(test);

		String expected = getDate(0);
		assertEquals(expected, show.getDate());
		assertTrue(show.getShowDone());
	}

	@Test
	public void testEmptyShowAction() {
		String test = "show";
		assertTrue(Parser.setCommand(test) instanceof ShowTask);

		ShowTask show = (ShowTask) Parser.setCommand(test);

		String expected = "";
		assertEquals(expected, show.getDate());
		assertFalse(show.getShowFloat());
		assertFalse(show.getShowDone());
	}

	@Test
	public void testFailedShowActionTooManyInputs() {
		String test = "show 10/11/15 11/11/15";
		assertTrue(Parser.setCommand(test) instanceof InvalidTask);
	}

	@Test
	public void testShowActionFloat() {
		String test = "display float";
		assertTrue(Parser.setCommand(test) instanceof ShowTask);

		ShowTask show = (ShowTask) Parser.setCommand(test);
		assertTrue(show.getShowFloat());
		assertFalse(show.getShowDone());
	}

	@Test
	public void testShowActionFloatAndDone() {
		String test = "show done float";
		assertTrue(Parser.setCommand(test) instanceof ShowTask);

		ShowTask show = (ShowTask) Parser.setCommand(test);
		assertTrue(show.getShowFloat());
		assertTrue(show.getShowDone());
	}
	
	@Test
	public void testClearAction() {
		String test = "clear";
		assertTrue(Parser.setCommand(test) instanceof ClearList);
	}

	// For easier adding to ArrayLists
	private static ArrayList<String> add(String start, String end) {
		ArrayList<String> returnArr = new ArrayList<String>();
		returnArr.add(start);
		returnArr.add(end);
		return returnArr;
	}
	
	private static String getDate(int plus) {
		LocalDateTime date = LocalDateTime.now();
		date = date.plusDays(plus);
		return date.toString("dd/MM/yy");
	}
}
```
